from beanie import Document, PydanticObjectId, Link
from pydantic import BaseModel, EmailStr, Field
from typing import Optional, Any
from datetime import datetime, timezone, timedelta
from enum import Enum
from pymongo import IndexModel

# my imports 
from src.dtos import Dictor
from src.dtos import TaskTypes, TaskStatus

#-----------------------
# User model
#-----------------------

# plane types -> for freemium
class PlanType(str, Enum):
  FREE = "free"
  STANDARD = 'standard'
  BRONZE = 'bronze'
  GOLD = "gold"

class User(Document):
  email: EmailStr
  name: str = Field(default="user") # some default value for the user 
  hashed_password: Optional[str] = None
  is_active: bool = True # for account deactivation

  # subscription info
  plan: PlanType = PlanType.FREE
  subscription_start: Optional[datetime] = None
  subscription_end: Optional[datetime] = None

  # usage stats -> for freemium limits
  total_pdfs_upload: int = 0
  total_pages_processes: int = 0 # pdf page processing
  total_tokens_used: int = 0 # embedding/chat

  # metadata
  created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
  updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

  class Settings:
    name  = 'users'# name of collection

  # methods 

#-----------------------
# Task model
#-----------------------

class Task(Document):
  task_type: TaskTypes
  status: TaskStatus = Field(default=TaskStatus.INCOMPLETE)
  payload: Dictor # dynamic data dictionary 
  retries: int = Field(default=0)
  max_retries: int = Field(default=5)
  error: Optional[str] = None

  created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
  updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
  completed_at: Optional[datetime] = None

  class Settings: 
    name = "tasks"

  async def mark_processing(self):
    """ mark a task processing by the worker """
    self.status = TaskStatus.PROCESSING
    self.updated_at = datetime.now(timezone.utc)
    await self.save()

  async def mark_done(self):
    """ mark a task as done, processed by the worker """
    self.status = TaskStatus.DONE
    self.completed_at = datetime.now(timezone.utc)
    self.updated_at = datetime.now(timezone.utc)
    await self.save()

  async def mark_failed(self, error_msg: str):
    """ 
     if: max_retries -> status = failed
     else: status = incomplete
    """

    self.error = error_msg
    self.retries += 1

    if self.retries < self.max_retries:
      # failed and done!
      self.status = TaskStatus.FAILED
    else:
      # still can try
      self.status = TaskStatus.INCOMPLETE
    
    self.updated_at = datetime.now(timezone.utc)
    await self.save()

#-----------------------
# Otp model
#-----------------------

# beanie orm
class Otp(Document):
  otp_code: str # required
  # await otp.user.fetch()
  user: Link[User] # reference to user doc

  # expiration
  #expires_at: datetime = datetime.now(timezone.utc) + timedelta(minutes=5) # 5 min
  expires_at: datetime = Field(
    default_factory=lambda: datetime.now(timezone.utc) + timedelta(minutes=5)
  )
  is_used: bool = False

  # metadata
  created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

  class Settings:
    name = "otps"
    
    # TTL index on expires_at field
    indexes: Any = [
      IndexModel([('expires_at', 1)], expireAfterSeconds=0),
    ]

  # methods

  def is_valid(self) -> bool:
    """ check otp is still valid (not expired , not used) """
    return not self.is_used and self.expires_at > datetime.now(timezone.utc)
  

#-----------------------
# Upload model
#-----------------------

from src.dtos import UploadStatus

class Upload(Document):
  upload_id: str # uuid generated by the client
  user: Link[User]
  percent: int = 0 # upload progress
  status: UploadStatus = UploadStatus.UPLOADING # upload status
  # gridfs
  file_id: Optional[str] = None # file id
  error: Optional[str] = None

  created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
  updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

  class Settings:
    name = "uploads"
    # auto clean this -> after an hour
    # indexes = [
    #   IndexModel([('updated_at', 1)], expiresAfterSeconds=3600)
    # ]